export default {
	name: "thread",
	version: "1.0.1",
	hasPermssion: 2,
	credits: "NDKh√°nh",
	description: "C·∫•m ho·∫∑c g·ª° c·∫•m nh√≥m!",
	shortDescription: "Qu·∫£n l√Ω Thread",
	usages: [
	"thread ban: ban nh√≥m b·∫°n th·ª±c thi l·ªánh",
	"thread ban <xxxx>: ban nh√≥m b·∫±ng TID",
	"thread unban: g·ª° ban nh√≥m b·∫°n th·ª±c thi l·ªánh",
	"thread unban <xxxx>: g·ª° ban nh√≥m b·∫±ng TID",
	"thread list: danh s√°ch nh√≥m trong d·ªØ li·ªáu BOT",
	"thread banned: qu·∫£n l√Ω danh s√°ch nh√≥m b·ªã ban",
	"thread cmd: qu·∫£n l√Ω commands nh√≥m",
	"thread cmd <xxxx>: qu·∫£n l√Ω commands b·∫±ng TID"
	],
	cooldowns: 5

}

import fs from "fs-extra"
import moment from "moment-timezone"

export async function handleReply({ event, api, ThreadsAll, client, handleReply }) {
    if (parseInt(event.senderID) !== parseInt(handleReply.author)) return api.sendMessage(`[ THREAD BANNED ]\n¬ª B·∫°n kh√¥ng ph·∫£i l√† ng∆∞·ªùi d√πng l·ªánh!`, event.threadID, async (error, info) => {
        await new Promise(resolve => setTimeout(resolve, 10000));
        return api.unsendMessage(info.messageID);
    });
	try {
	switch (handleReply.type) {
		case "ban": {
			const gio = moment.tz("Asia/Ho_Chi_Minh").format("HH:mm D/MM/YYYY");  
            const reasonban = event.body
			const ThreadsData = ThreadsAll.find(item => item.threadID == handleReply.target);
            ThreadsData.banned = true;
            ThreadsData.reasonban = reasonban
			ThreadsData.timebanned = gio
			fs.writeFileSync(client.dirMain + "/data/Thread.json",JSON.stringify(ThreadsAll, null, "\t"));
			return api.sendMessage(`[ THREAD BANNED ]\n¬ª ƒê√£ ban th√†nh c√¥ng nh√≥m!\n¬ª NAME: ${ThreadsData.threadName}\n¬ª TID: ${handleReply.target}\n¬ª L√Ω do: ${reasonban}\n¬ª V√†o l√∫c: ${gio}`, event.threadID, async (error, info) => { 
                api.unsendMessage(handleReply.messageID)
                await new Promise(resolve => setTimeout(resolve, 10000));
                return api.unsendMessage(info.messageID);
            });
			break;
		}
		case "list": {
			let arg = event.body.split(" ");
			let idgr = handleReply.target[arg[1]-1];
			if(arg[0] == "ban" || arg[0] == "Ban") {
			let reason = arg.slice(2).join(" ")
			if(!reason) reason = "Kh√¥ng c√≥ l√Ω do n√†o ƒë∆∞·ª£c ƒë∆∞a ra";
			api.sendMessage(`[ THREAD BAN ]\n¬ª ƒê√£ nh·∫≠n l·ªánh BAN nh√≥m t·ª´ admin\n¬ª V·ªõi l√Ω do: ${reason}`, idgr, async (error, info) => {
                await new Promise(resolve => setTimeout(resolve, 10000));
                return api.unsendMessage(info.messageID);
            });
			const gio = moment.tz("Asia/Ho_Chi_Minh").format("HH:mm D/MM/YYYY");  
			const ThreadsData = ThreadsAll.find(item => item.threadID == idgr);
            ThreadsData.banned = true;
            ThreadsData.reasonban = reason
			ThreadsData.timebanned = gio
			fs.writeFileSync(client.dirMain + "/data/Thread.json",JSON.stringify(ThreadsAll, null, "\t"));
			return api.sendMessage(`[ THREAD BANNED ]\n¬ª ƒê√£ ban th√†nh c√¥ng nh√≥m!\n¬ª NAME: ${ThreadsData.threadName}\n¬ª TID: ${idgr}\n¬ª L√Ω do: ${reason}\n¬ª V√†o l√∫c: ${gio}`, event.threadID, async (error, info) => { 
                api.unsendMessage(handleReply.messageID)
                await new Promise(resolve => setTimeout(resolve, 10000));
                return api.unsendMessage(info.messageID);
            });
	        }
			if(arg[0] == "out" || arg[0] == "Out") {
				let reason = arg.slice(2).join(" ")
				if(!reason) reason = "Kh√¥ng c√≥ l√Ω do n√†o ƒë∆∞·ª£c ƒë∆∞a ra";
				const ThreadsData = ThreadsAll.find(item => item.threadID == idgr);
	            api.sendMessage(`[ THREAD OUT ]\n¬ª ƒê√£ nh·∫≠n l·ªánh out nh√≥m t·ª´ admin\n¬ª V·ªõi l√Ω do: ${reason}`, idgr, () =>
	            api.removeUserFromGroup(`${api.getCurrentUserID()}`, idgr));
	            api.sendMessage(`[ THREAD OUT ]\n¬ª ƒê√£ Out th√†nh c√¥ng nh√≥m!\n¬ª TID: ${idgr}\n¬ª NAME: ${ThreadsData.threadName}\n¬ª V·ªõi l√Ω do: ${reason}`, event.threadID, async (error, info) => { 
					api.unsendMessage(handleReply.messageID)
					await new Promise(resolve => setTimeout(resolve, 10000));
					return api.unsendMessage(info.messageID);
				});
			}
			if(arg[0] == "Noti" || arg[0] == "noti") {
				let reason = arg.slice(2).join(" ")
				if(!reason) return api.sendMessage(`N·ªôi dung th√¥ng b√°o kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!`, event.threadID, () => api.unsendMessage(handleReply.messageID));
				const ThreadsData = ThreadsAll.find(item => item.threadID == idgr);
	            api.sendMessage(`[ THREAD NOTIFICATION ]\n¬ª Th√¥ng B√°o T·ª´ ADMINBOT G·ª≠i ƒê·∫øn Nh√≥m B·∫°n!\n   ‚ä± ‚ãÖ ‚îÄ üÖÇüÖÑüÑºüÑ∏üÑ≤üÑ∑üÑ∞üÑΩ ‚îÄ ‚ãÖ ‚ä∞\n${reason}`, idgr);
	            api.sendMessage(`[ THREAD NOTIFICATION ]\n¬ª ƒê√£ g·ª≠i th√¥ng b√°o th√†nh c√¥ng:\n¬ª TID: ${idgr}\n¬ª NAME: ${ThreadsData.threadName}`, event.threadID, async (error, info) => { 
					api.unsendMessage(handleReply.messageID)
					await new Promise(resolve => setTimeout(resolve, 10000));
					return api.unsendMessage(info.messageID);
				});
				}
				if(arg[0] == "Info" || arg[0] == "info") {
					api.sendMessage(`[ THREAD INFO ]\n¬ª UPDATE SAU`, event.threadID, async (error, info) => { 
						api.unsendMessage(handleReply.messageID)
						await new Promise(resolve => setTimeout(resolve, 10000));
						return api.unsendMessage(info.messageID);
					});
				}
				break;	
	    	}
			case "unban": {
				const ThreadsData = ThreadsAll.find(item => item.threadID == handleReply.target[event.body - 1]);
				ThreadsData.banned = false;
				ThreadsData.reasonban = ""
				ThreadsData.timebanned = ""
				fs.writeFileSync(client.dirMain + "/data/Thread.json",JSON.stringify(ThreadsAll, null, "\t"));
				return api.sendMessage(`[ THREAD UNBAN ]\n¬ª ƒê√£ unban th√†nh c√¥ng nh√≥m!\n¬ª NAME: ${ThreadsData.threadName}\n¬ª TID: ${handleReply.target[event.body - 1]}`, event.threadID, async (error, info) => { 
					api.sendMessage(`[ THREAD UNBAN ]\n¬ª Nh√≥m b·∫°n ƒë√£ ƒë∆∞·ª£c ADMIN BOT g·ª° ban!\n   ‚ä± ‚ãÖ ‚îÄ üÖÇüÖÑüÑºüÑ∏üÑ≤üÑ∑üÑ∞üÑΩ ‚îÄ ‚ãÖ ‚ä∞`, handleReply.target[event.body - 1], async (error, info) => {
						await new Promise(resolve => setTimeout(resolve, 10000));
						return api.unsendMessage(info.messageID);
					});
					api.unsendMessage(handleReply.messageID)
					await new Promise(resolve => setTimeout(resolve, 10000));
					return api.unsendMessage(info.messageID);
				});
				break;
			}
			case "command": {
				switch (event.body) {
					case "1": {
						let msg = "", i = 1, arrayCmd = []; 
						const ThreadsData = ThreadsAll.find(item => item.threadID == handleReply.target);
						for (let getCmd of ThreadsData.commandBanned) {
							msg += `${i++}/ Commands: ${getCmd.cmd}\n¬ª TimeBan: ${getCmd.timebanned}\n`
							arrayCmd.push(getCmd.cmd);
						}
						api.unsendMessage(handleReply.messageID)
						return	msg == "" ?
            api.sendMessage('[ ‚úÖ THREAD BANNED ]\n¬ª Hi·ªán t·∫°i kh√¥ng c√≥ commands n√†o b·ªã ban',
                event.threadID,
                event.messageID
            ) :  api.sendMessage(`[ THREAD UNBANCMD ]\n${msg}\n¬ª Reply s·ªë t·ª© th·ª± ƒë·ªÉ unban commands ƒë√≥!`, event.threadID, (error, info) => {
							client.handleReply.push({
								name: this.default.name,
								messageID: info.messageID,
								author: event.senderID,
								type: "unbanCmd",
								target: handleReply.target,
								cmd: arrayCmd
							});
						}, event.messageID);
						break;
					}
					case "2": {
						api.unsendMessage(handleReply.messageID)
						return api.sendMessage(`[ THREAD BANCMD ]\n¬ª Reply tin nh·∫Øn \n¬ª Command ban | L√Ω do ban`, event.threadID, (error, info) => {
							client.handleReply.push({
								name: this.default.name,
								messageID: info.messageID,
								author: event.senderID,
								type: "banCmd",
								target: handleReply.target
							});
						}, event.messageID);	
					}
				}
				break;
			}
			case "banCmd": {
				let arg = event.body.split(" ");
				let reason = arg.slice(1).join(" ")
				if(!reason) reason = "Kh√¥ng c√≥ l√Ω do n√†o ƒë∆∞·ª£c ƒë∆∞a ra";
				const gio = moment.tz("Asia/Ho_Chi_Minh").format("HH:mm D/MM/YYYY");
				const allCommandName = [];
			    for (const cmd of client.commands) allCommandName.push(cmd.config.name);
				if (!allCommandName.includes(arg[0])) return api.sendMessage(`[ ‚õîÔ∏è THREAD BANCMD ]\n¬ª L·ªánh b·∫°n c·∫•m kh√¥ng t·ªìn t·∫°i\n\n¬ª ERROR ${arg[0]}`, event.threadID, async (error, info) => {
					await new Promise(resolve => setTimeout(resolve, 5000));
					return api.unsendMessage(info.messageID);
				});  
				const ThreadsData = ThreadsAll.find(item => item.threadID == handleReply.target);
				ThreadsData.commandBanned.push({cmd: arg[0], reasonban: reason, timebanned: gio})
				fs.writeFileSync(client.dirMain + "/data/Thread.json",JSON.stringify(ThreadsAll, null, "\t"));
				return api.sendMessage(`[ THREAD BANCMD ]\n¬ª ƒê√£ ban th√†nh c√¥ng commands!\n¬ª ${arg[0]}\n¬ª V·ªõi l√Ω do: ${reason}`, event.threadID, async (error, info) => { 
					api.unsendMessage(handleReply.messageID)
					await new Promise(resolve => setTimeout(resolve, 10000));
					return api.unsendMessage(info.messageID);
				});
				break;
			}
			case "unbanCmd": {
			  const ThreadsData = ThreadsAll.find(item => item.threadID == handleReply.target);
				ThreadsData.commandBanned.splice(ThreadsData.commandBanned.findIndex(item => item.cmd == handleReply.cmd[event.body - 1]), 1)
				fs.writeFileSync(client.dirMain + "/data/Thread.json",JSON.stringify(ThreadsAll, null, "\t"));
				return api.sendMessage(`[ THREAD UNBANCMD ]\n¬ª ƒê√£ unban th√†nh c√¥ng commands!\n¬ª ${handleReply.cmd[event.body - 1]}`, event.threadID, async (error, info) => { 
					api.unsendMessage(handleReply.messageID)
					await new Promise(resolve => setTimeout(resolve, 10000));
					return api.unsendMessage(info.messageID);
				});
				break;
			}
		default:
			return;
	}
    } catch (e) { console.log(e) }
}

export async function handleReaction ({ event, api, ThreadsAll, client, handleReaction }) {
	if (parseInt(event.userID) !== parseInt(handleReaction.author)) return api.sendMessage(`[ THREAD BANNED ]\n¬ª B·∫°n kh√¥ng ph·∫£i l√† ng∆∞·ªùi d√πng l·ªánh!`, event.threadID, async (error, info) => {
        await new Promise(resolve => setTimeout(resolve, 10000));
        return api.unsendMessage(info.messageID);
    });
	try {
	switch (handleReaction.type) {
		case "ban": {
            const gio = moment.tz("Asia/Ho_Chi_Minh").format("HH:mm D/MM/YYYY");  
            const reasonban = "Kh√¥ng c√≥ l√Ω do n√†o ƒë∆∞·ª£c ƒë∆∞a ra!" 
			const ThreadsData = ThreadsAll.find(item => item.threadID == handleReaction.target);
            ThreadsData.banned = true;
            ThreadsData.reasonban = reasonban
			ThreadsData.timebanned = gio
			fs.writeFileSync(client.dirMain + "/data/Thread.json",JSON.stringify(ThreadsAll, null, "\t"));
			return api.sendMessage(`[ THREAD BANNED ]\n¬ª ƒê√£ ban th√†nh c√¥ng nh√≥m!\n¬ª NAME: ${ThreadsData.threadName}\n¬ª TID: ${handleReaction.target}\n¬ª L√Ω do: ${reasonban}\n¬ª V√†o l√∫c: ${gio}`, event.threadID, async (error, info) => { 
                api.unsendMessage(handleReaction.messageID)
                await new Promise(resolve => setTimeout(resolve, 10000));
                return api.unsendMessage(info.messageID);
            });
			break;
		}
		case "unban": {
			const ThreadsData = ThreadsAll.find(item => item.threadID == handleReaction.target);
            ThreadsData.banned = false;
            ThreadsData.reasonban = ""
			ThreadsData.timebanned = ""
			fs.writeFileSync(client.dirMain + "/data/Thread.json",JSON.stringify(ThreadsAll, null, "\t"));
			return api.sendMessage(`[ THREAD UNBAN ]\n¬ª ƒê√£ unban th√†nh c√¥ng nh√≥m!\n¬ª NAME: ${ThreadsData.threadName}\n¬ª TID: ${handleReaction.target}`, event.threadID, async (error, info) => { 
                api.sendMessage(`[ THREAD UNBAN ]\n¬ª Nh√≥m b·∫°n ƒë√£ ƒë∆∞·ª£c ADMIN BOT g·ª° ban!\n   ‚ä± ‚ãÖ ‚îÄ üÖÇüÖÑüÑºüÑ∏üÑ≤üÑ∑üÑ∞üÑΩ ‚îÄ ‚ãÖ ‚ä∞`, handleReaction.target, async (error, info) => {
					await new Promise(resolve => setTimeout(resolve, 10000));
					return api.unsendMessage(info.messageID);
				});
				api.unsendMessage(handleReaction.messageID)
                await new Promise(resolve => setTimeout(resolve, 10000));
                return api.unsendMessage(info.messageID);
            });
		}
		default:
			return;
	}
    } catch (e) { console.log(e) }
}

export async function run({ event, api, args, ThreadsAll, client, utils }) {
	try {
    let content = args.slice(1, args.length);
	switch (args[0]) {
		case "ban": {
			const idBan = content[0] || event.threadID
            if (isNaN(idBan)) return api.sendMessage(`[ THREAD BANNED ]\n¬ª ${idBan} kh√¥ng ph·∫£i l√† IDthread!`, event.threadID);
            const ThreadsData = ThreadsAll.find(item => item.threadID == idBan);
            if (!ThreadsData) return api.sendMessage(`[ THREAD BANNED ]\n¬ª Thread kh√¥ng t·ªìn t·∫°i trong database!\n¬ª TID: ${idBan}`, event.threadID);
            if (ThreadsData.banned) return api.sendMessage(`[ THREAD BANNED ]\n¬ª TID: ${idBan}\n¬ª ƒê√£ b·ªã ban t·ª´ tr∆∞·ªõc`, event.threadID);
            return api.sendMessage(`[ THREAD BANNED ]\n¬ª B·∫°n mu·ªën ban thread n√†y ?\n¬ª NAME: ${ThreadsData.threadName}\n¬ª TID: ${idBan}\n\n¬ª Reaction v√†o tin nh·∫Øn n√†y ƒë·ªÉ ban!\n¬ª Reply v√†o tin nh·∫Øn n√†y ƒë·ªÉ ghi l√Ω do ban!`, event.threadID, (error, info) => {
                client.handleReaction.push({
                    name: this.default.name,
                    messageID: info.messageID,
                    author: event.senderID,
                    type: "ban",
                    target: idBan
                });
                client.handleReply.push({
                    name: this.default.name,
                    messageID: info.messageID,
                    author: event.senderID,
                    type: "ban",
                    target: idBan
                });
            })	
			break;
		}
		case "unban": {
			const idBan = content[0] || event.threadID
            if (isNaN(idBan)) return api.sendMessage(`[ THREAD UNBAN ]\n¬ª ${idBan} kh√¥ng ph·∫£i l√† IDthread!`, event.threadID);
            const ThreadsData = ThreadsAll.find(item => item.threadID == idBan);
            if (!ThreadsData) return api.sendMessage(`[ THREAD UNBAN ]\n¬ª Thread kh√¥ng t·ªìn t·∫°i trong database!\n¬ª TID: ${idBan}`, event.threadID);
            if (!ThreadsData.banned) return api.sendMessage(`[ THREAD UNBAN ]\n¬ª TID: ${idBan}\n¬ª Kh√¥ng b·ªã ban t·ª´ tr∆∞·ªõc`, event.threadID);
            return api.sendMessage(`[ THREAD UNBAN ]\n¬ª B·∫°n mu·ªën unban thread n√†y ?\n¬ª NAME: ${ThreadsData.threadName}\n¬ª TID: ${idBan}\n\n¬ª Reaction v√†o tin nh·∫Øn n√†y ƒë·ªÉ unban!`, event.threadID, (error, info) => {
                client.handleReaction.push({
                    name: this.default.name,
                    messageID: info.messageID,
                    author: event.senderID,
                    type: "unban",
                    target: idBan
                });
            })	
			break;
		}
		case "list": {
			if (!args[1] || !isNaN(args[1])) {
				const numberOfOnePage = 20;
				const page = parseInt(args[1]) || 1;
				let msg = "", listthread = [], groupid = [];
				let i = 0;
				let startSlice = numberOfOnePage * page - numberOfOnePage;
				i = startSlice;
				if(page > parseInt(Math.ceil(ThreadsAll.length / numberOfOnePage))) return;
				else {
					const threadOfPage = ThreadsAll.slice(startSlice, startSlice + numberOfOnePage);
					for (let thread of threadOfPage) {
						listthread.push({
							id: thread.threadID,
							name: thread.threadName,
							sotv: thread.participantIDs.length,
							active: thread.approvalMode,
							banned: thread.banned
						});
					}
					const listbox = listthread.sort((a, b) => {
						if (a.sotv > b.sotv) return -1;
						if (a.sotv < b.sotv) return 1;
					});
					for (let group of listbox) {
					msg += `${++i}/ ${group.name}\n¬ª TID: ${group.id}\n¬ª S·ªë Th√†nh Vi√™n : ${group.sotv}\n¬ª Ph√™ duy·ªát : ${((group.active == true) ? "‚úÖ" : "‚ùé")} | Banned : ${((group.banned == true) ? "‚úÖ" : "‚ùé")}\n\n`;
					groupid.push(group.id);
					}
					return api.sendMessage(`[ THREAD LIST ]\n${msg}¬ª Trang [ ${page}/${Math.ceil(ThreadsAll.length / numberOfOnePage)} ]\n¬ª Reply s·ªë th·ª© t·ª± ƒë·ªÉ\n¬ª [Ban/Info/Noti/Out]`, event.threadID, (error, info) => {
						client.handleReply.push({
							name: this.default.name,
							messageID: info.messageID,
							author: event.senderID,
							type: "list",
							target: groupid
						});
					})
				}
			} else return utils.throwError(this.default.name, event.threadID, event.messageID);
			break;
		}
		case "banned": {
			let msg = "", listid = [], number = 1;
			const in4thr = async(idthr) => {
				let ThreadsData = ThreadsAll.find(item => item.threadID == idthr);
				return `Name: ${ThreadsData.threadName}\n¬ª TID: ${idthr}\n`;
			};
			for (let idthr of ThreadsAll) {
				let ThreadsData = ThreadsAll.find(item => item.threadID == idthr.threadID);
				if (ThreadsData.banned == true) {
					msg += `${number++}. ${(await in4thr(idthr.threadID))}`;
					listid.push(idthr.threadID);
				}
			};
			msg == "" ?
            api.sendMessage('[ ‚úÖ THREAD BANNED ]\n¬ª Hi·ªán t·∫°i kh√¥ng c√≥ nh√≥m n√†o b·ªã ban',
                event.threadID,
                event.messageID
            ) : api.sendMessage(
                '[ ‚ùé THREAD BANNED ]\n¬ª Nh·ªØng nh√≥m ƒë√£ b·ªã ban kh·ªèi h·ªá th·ªëng bot g·ªìm:\n\n' + msg + "\nReply tin nh·∫Øn n√†y + s·ªë th·ª© t·ª± ƒë·ªÉ unban nh√≥m t∆∞∆°ng ·ª©ng",
                event.threadID, (error, info) => {
                        client.handleReply.push({
                        name: this.default.name,
                        messageID: info.messageID,
                        author: event.senderID,
                        type: 'unban',
						target: listid
                    });
                },
                event.messageID
            );
			break;
		}
		case "cmd": {
			const idBan = content[0] || event.threadID
			return api.sendMessage(`[ THREAD COMMAND ]\n¬ª 1/ Xem danh s√°ch commands b·ªã ban!\n¬ª 2/ Ban commands nh√≥m!`, event.threadID, (error, info) => {
                client.handleReply.push({
                    name: this.default.name,
                    messageID: info.messageID,
                    author: event.senderID,
                    type: "command",
					target: idBan
                });
            }, event.messageID);
			break;
		}
		default:
			return;
	}
    } catch (e) {console.log(e) }
} 